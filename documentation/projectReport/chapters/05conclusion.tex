\chapter{Conclusion}
\label{sec:conclusion}

\section{Reached goals}
During the project, a stable simulation of the FINken quadcopter was built.
The performance of the simulation needs to be improved for bigger quadcopter swarms, but one real FINken can be connected to one simulated FINken running in real time on any modern computer.
The simulation reproduces the real FINken's movements sufficiently as shown in \ref{sec:accuracy}.

A Java API was build, that manages the V-REP scene and communication to the quadcopters. 
The API is very modular and comprises of several stand alone projects, each of which can be reused for other projects and mixed-reality simulations. The software architecture was build according to the  SOLID \cite{solid} principles.
The design uses abstraction layers between the modules, which make it possible to benefit from the open-closed principle and add new functionality without changing existing code.

The communication between VREP and the real FINken is fast enough to send new data for every simulation timestep.
The controllers of the virtual FINken adapt the new target values quickly and the movements of the real quadcopter can be observed in the virtual one.
Internal sensor noise and inaccuracies and a missing external reference let the virtual FINken drift away.
Correctly calibrating the FINken's internal sensor vastly improved the drift by removing sensor offsets.
However, stable flight is only possible for typically half a minute, then, the cumulated errors let the virtual FINken drift out of the arena.

A major problem for the simulation is the drift around the $z$ axis.
When starting the FINken, often it starts yawing heavily right after take off.
This yaw occurs due to sensor errors and resulting wrong correction commands to the motor controllers.
Hence this error can't be detected and falsifies the simulation.
With a different yaw angle, the coordinate systems of the real and virtual copter aren't aligned anymore, so pitch and roll commands result in movement into different directions.
When this behaviour was observed, the experiment was aborted, as no useful results could be obtained.
Until now, the cause of this behaviour could not be found.





\section{Future Work}
\begin{itemize}
\item{enhance the stability of the mixed reality simulation}
\item{include the sensor data from the optical flow and ultrasound sensors for the positioning of the virtual quadcopter}
\item{implement real swarm algorithms with the framework}
\item{}
\end{itemize}
%Die Beurteilung ist einer der wichtigsten Abschnitte der Arbeit
%- Sie enthält die Quintessenz des gesamten Projektes
%Viele lesen nur die Einführung und die Beurteilung an
%- Hier muss also alles Wichtige drin stehen!
%Hier beweisen Sie dass Sie …
%- die Aufgabe und deren Bedeutung verstanden haben
%- die Ergebnisse richtig zu interpretieren vermögen
%- wissen, worauf es bei diese Arbeit ankam




% example for definition
%      \begin{definitionnonum} [Hierarchische Struktur] 
%      Wenn eine Softwarestruktur als Menge von Komponenten  und Relationen zwischen den Komponenten beschrieben wird, gilt diese Struktur als hierarchisch, wenn eine Relation oder ein Prädikat $R(\alpha, \beta)$ über Paaren dieser Komponenten Schichten folgendermaßen beschreiben kann: 
%      \begin{itemize} 
%      \item{Schicht 0 ist eine Menge von Komponenten $\alpha$, sodass  kein $\beta$ mit $R(\alpha,\beta)$ existiert} 
%      \item{Schicht $i$ ist eine Menge von Komponenten $\alpha$ ist, sodass auf Level $i-1$ ein $\beta$ existiert mit $R(\alpha,\beta)$ und alle $\gamma$ für $R(\alpha,\gamma)$ in der Schicht $i-1$ oder niedriger liegen} 
%      \end{itemize}
%      \end{definitionnonum}
      


% example for drawing      
%              \tikzstyle{decision} = [diamond, draw, fill=blue!20,
%    text width=4.5em, text badly centered, node distance=2.5cm, inner sep=0pt]
%\tikzstyle{block} = [rectangle, draw, fill=blue!20,
%    text width=5em, text centered, rounded corners, minimum height=4em]
%\tikzstyle{line} = [draw, very thick, color=black!50, -latex']
%\tikzstyle{cloud} = [draw, ellipse,fill=red!20, node distance=2.5cm,
%    minimum height=2em]
%\tikzstyle{node} = [draw, ellipse, node distance=2.5cm,
%    minimum height=2em]
%\tikzstyle{fullnode}= [draw, ellipse,fill=black!20, node distance=2.5cm,
%    minimum height =2em]
%\begin{figure}[h]
%\begin{center}
%\begin{tikzpicture}[scale=2, node distance = 2cm, auto]
%    % Place nodes
%  \node[node](b1){$b_1$};
%   \node[node, below of=b1, right of=b1](b3){$b_3$};
% \node[node, right of=b3, above of=b3](b2){$b_2$};
%
%
%\path [->, densely dotted] (b1) edge node{e} (b2);
%\path [->] (b1) edge (b3);
%\path [->] (b3) edge (b2);
%\path [->, dashed] (b1) edge[bend right] node[left]{$e_1$}(b3);
%\path [->,dashed] (b3) edge[bend right]  node[right]{$e_2$} (b2);
%\end{tikzpicture}
%\caption{Beispiel Gesetz von Demeter}
%\end{center}
%\end{figure}




% example for equation   
%\begin{equation}
%   L_{GvD}(a) = \sum_{b_i \in B(a)} L_{GvD}(b_i)
%\end{equation}
%    
      
