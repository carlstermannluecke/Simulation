\chapter{Conclusion}
\label{chap:conclusion}

\section{Reached goals}
\label{sec:conclusionGoals}
During the project, a stable simulation of the FINken quadcopter was built.
The performance of the simulation needs to be improved for bigger quadcopter swarms, but one real FINken can be connected to one simulated FINken running in real time on any modern computer.
The simulation reproduces the real FINken's movements sufficiently as shown in \ref{sec:accuracy}.
The simulation is based on un-threaded Lua scripts attached to the simulation objects.
The scripts are stored outside V-REP and have a modular structure.
A base class provides attitude control and a flight control API.
Additionally, custom functionalities can be implemented in Lua in a custom class for each virtual FINken.


A Java API was build, that manages the V-REP scene and communication to the quadcopters. 
The API is very modular and comprises of several stand-alone projects, each of which can be reused for other projects and mixed-reality simulations. The software architecture was build according to the  SOLID \cite{solid} principles.
The design uses abstraction layers between the modules, which make it possible to benefit from the open-closed principle and add new functionality without changing existing code.

The communication between V-REP and the real FINken is fast enough to send new data for every simulation time step.
The controllers of the virtual FINken adapt the new target values quickly and the movements of the real quadcopter can be observed in the virtual one.
Internal sensor noise and inaccuracies and a missing external reference let the virtual FINken drift away.
Correctly calibrating the FINken's internal sensor vastly improved the drift by removing sensor offsets.
However, stable flight is only possible for typically half a minute, then, the cumulated errors let the virtual FINken drift out of the arena.

A major problem for the simulation is the drift around the $z$ axis.
When starting the FINken, often it starts yawing heavily right after takeoff.
This yaw occurs due to sensor errors and resulting wrong correction commands to the motor controllers.
Hence this error can't be detected and falsifies the simulation.
With a different yaw angle, the coordinate systems of the real and virtual copter aren't aligned anymore, so pitch and roll commands result in movement into different directions.
When this behavior was observed, the experiment was aborted, as no useful results could be obtained.
Until now, the cause of this behavior could not be found.





\section{Future Work}
\label{sec:future}
The fundamentals for a mixed reality simulation were set during this work.
However, it would be desirable to get a stable simulation for the whole quadcopter flight time to use the mixed reality simulation for longer scenarios.
A first step towards this goal could be to include data form the ultrasound sensors and the optical flows sensor which was set up parallel to this project.
These sensors would provide a reference to the environment and a sensor fusion would have a major positive benefit on the accuracy of the virtual copters position.
For evaluation purposes, an external reference system by optical tracking the copters could be used to get better internal sensor models by comparing the internal sensor data with the results from the external system.

Another idea would be to use the simulation environment to test the software that runs on the copter, by loading the C-code running on the copter into the simulation.
This would most likely need a more detailed physical model, but would have the benefit of detecting problem completely without risking the expensive hardware.

Additionally, in the case described above, the API of the real and virtual copters would be identical. 
However, this could be achieved more easily, and would make it easier to test scenarios with multiple FINkens without the need to differentiate between real world and simulation.


The simulation  provides the possibility to implement swarm algorithms that should later be handled by the real FINken.
This could be started right away, but defining a API first that can be handled by real FINkens and simulation would increase the reuse of this work.

To scale the simulation, it is desirable to split the computation tasks into multiple threads, increasing simulation performance on multi-core computers.


%Die Beurteilung ist einer der wichtigsten Abschnitte der Arbeit
%- Sie enthält die Quintessenz des gesamten Projektes
%Viele lesen nur die Einführung und die Beurteilung an
%- Hier muss also alles Wichtige drin stehen!
%Hier beweisen Sie dass Sie …
%- die Aufgabe und deren Bedeutung verstanden haben
%- die Ergebnisse richtig zu interpretieren vermögen
%- wissen, worauf es bei diese Arbeit ankam




% example for definition
%      \begin{definitionnonum} [Hierarchische Struktur] 
%      Wenn eine Softwarestruktur als Menge von Komponenten  und Relationen zwischen den Komponenten beschrieben wird, gilt diese Struktur als hierarchisch, wenn eine Relation oder ein Prädikat $R(\alpha, \beta)$ über Paaren dieser Komponenten Schichten folgendermaßen beschreiben kann: 
%      \begin{itemize} 
%      \item{Schicht 0 ist eine Menge von Komponenten $\alpha$, sodass  kein $\beta$ mit $R(\alpha,\beta)$ existiert} 
%      \item{Schicht $i$ ist eine Menge von Komponenten $\alpha$ ist, sodass auf Level $i-1$ ein $\beta$ existiert mit $R(\alpha,\beta)$ und alle $\gamma$ für $R(\alpha,\gamma)$ in der Schicht $i-1$ oder niedriger liegen} 
%      \end{itemize}
%      \end{definitionnonum}
      


% example for drawing      
%              \tikzstyle{decision} = [diamond, draw, fill=blue!20,
%    text width=4.5em, text badly centered, node distance=2.5cm, inner sep=0pt]
%\tikzstyle{block} = [rectangle, draw, fill=blue!20,
%    text width=5em, text centered, rounded corners, minimum height=4em]
%\tikzstyle{line} = [draw, very thick, color=black!50, -latex']
%\tikzstyle{cloud} = [draw, ellipse,fill=red!20, node distance=2.5cm,
%    minimum height=2em]
%\tikzstyle{node} = [draw, ellipse, node distance=2.5cm,
%    minimum height=2em]
%\tikzstyle{fullnode}= [draw, ellipse,fill=black!20, node distance=2.5cm,
%    minimum height =2em]
%\begin{figure}[h]
%\begin{center}
%\begin{tikzpicture}[scale=2, node distance = 2cm, auto]
%    % Place nodes
%  \node[node](b1){$b_1$};
%   \node[node, below of=b1, right of=b1](b3){$b_3$};
% \node[node, right of=b3, above of=b3](b2){$b_2$};
%
%
%\path [->, densely dotted] (b1) edge node{e} (b2);
%\path [->] (b1) edge (b3);
%\path [->] (b3) edge (b2);
%\path [->, dashed] (b1) edge[bend right] node[left]{$e_1$}(b3);
%\path [->,dashed] (b3) edge[bend right]  node[right]{$e_2$} (b2);
%\end{tikzpicture}
%\caption{Beispiel Gesetz von Demeter}
%\end{center}
%\end{figure}




% example for equation   
%\begin{equation}
%   L_{GvD}(a) = \sum_{b_i \in B(a)} L_{GvD}(b_i)
%\end{equation}
%    
      
